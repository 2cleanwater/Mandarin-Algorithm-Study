## 5주차 회고

### seungyeonpark
<details>
<summary>23881번 선택 정렬</summary>
<div markdown="1">
  
- 목록을 총 N-1번 훒으며 다음 과정 반복
  - 첫 번째 요소는 0부터 훑으며 최솟값을 찾아 요소 0과 교환
  - 두 번째 요소는 1부터 훑으며 최솟값을 찾아 요소 1과 교환
  - 세 번째 요소는 2부터 훑으며 최솟값을 찾아 요소 2와 교환
  - N - 1번까지 반복
- 최솟값을 찾아 선택한다 해서 선택 정렬
  - 최댓값을 이용할 수도 있음
- 시간 복잡도
  - O(N^2)
- 공간 복잡도
  - O(1)
- 안정성
  - 보장 X
  
</div>
</details>

<details>
<summary>23968번 버블 정렬</summary>
<div markdown="1">

- 이웃 요소 둘을 비교해 올바른 순서로 고치는 과정을 반복
- 시간 복잡도
  - O(N^2)
- 공간 복잡도
  - O(1)
- 안정성
  - 보장 O
  
</div>
</details>

<details>
<summary>24051번 삽입 정렬</summary>
<div markdown="1">

- 목록을 차례대로 훑으며 다음 과정을 반복
  - 현재 위치의 요소(target)를 뽑음
  - 과거 방문했던 요소들 중 뽑은 요소(target)를 어디에 삽입해야 정렬이 유지되는지 판단
  - 해당 위치에 삽입 & 다른 요소들 오른쪽으로 shift
- 시간 복잡도
  - O(N^2)
- 공간 복잡도
  - O(1)
- 안정성
  - 보장 O
  
</div>
</details>

<details>
<summary>24060번 병합 정렬</summary>
<div markdown="1">
  
- 원본 배열을 정렬된 여러 배열로 만든 뒤, 병합하는 정렬
- 단계
  ```
  1. 입력 배열을 재귀적으로 반씩 나눠 요소수가 1인 배열들로 만든다
    - 요소수가 1이니 무조건 정렬된 배열
    - 정확히 반씩 나누니 재귀 깊이는 O(logn)
  2. 재귀 반대 방향으로 배열을 계속 합침
    - 정렬된 상태를 유지하며 병합해야 함
    - 각 재귀 단계마다 방문하는 요소수는 O(n)
  3. 제일 상위 단계까지 합치면 정렬 끝
  ```
- 시간 복잡도
  - O(nlogn)
- 공간 복잡도
  - O(n)
- 안정성
  - 보장 O

</div>
</details>

<details>
<summary>24090번 퀵 정렬</summary>
<div markdown="1">
  
- divide-and-conquer
- 어떤 값(pivot)을 기준으로 하위 목록 2개로 나눔
  - 목록을 나누는 기준은 pivot보다 작냐/크냐
  - 이 과정을 재귀적으로 반복
  - 재귀 단계가 깊어질 때마다 새로운 pivot 값을 뽑음
- 단계
  ```
  1. 가장 오른쪽 값을 pivot으로 선정
  2. left에서부터 하나씩 pivot값과 비교
    - pivot 값보다 작으면 left에 있는 요소와 교환 후, left를 한 칸 이동
    - pivot 값보다 크면 아무 것도 하지 않고 다음 요소 비교하러 감~
    - 그렇게 pivot 직전 값까지 비교
  3. left와 right 교환
  ```
- 시간 복잡도
  - 평균: O(logn)
  - 최악: O(N^2)
- 공간 복잡도
  - O(logn)
  - 함수 호출 깊이만큼 스택 메모리 사용
  
</div>
</details>
