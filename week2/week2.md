## 2주차 회고

### 2cleanwater
* 2941번(크로아티아 알파벳)
   *  if else문을 사용하여 글자수가 2개인 경우와 3개인 경우로 나누어 처리했다.
   *  문자 for문을 돌리면 마지막, 마지막 - 1인 부분에서 그 다음 체크할 문자가 없어서 오류가 발생했기 때문에 일정 조건이 성립하면 하면 하나의 문자열로 계산하고 i를 그만큼 증가시켜 체크를 하지 않도록 작성했다.
   *  조건에 맞는 모든 문자를 체크하려다보니 if문의 조건식이 너무 복잡해졌다.
   *  ver.2에선 문자열을 하나씩 체크하지 않고 String에서 특정 문자열을 변환하는 `replaceAll(,)`을 사용했다.
   *  체크된 문자열은 'a'로 변환시킨 후 String의 length를 출력하는 방식으로도 해결이 가능한 것을 확인했다.
*  1316번(그룹 단어 체커)
   *  처음엔 체크할 정수가 100 이하의 자연수이기 때문에 'boolean [100]'의 배열을 할당해 단어를 체크하려 했다.
   *  하지만 예전에 사용되었던 알파벳인지 체크하려면 다중 for문을 이용해야하고 매커니즘이 너무 복잡해졌다.
   *  따라서 알파벳 전체를 체크하는 'boolean[26]'을 만들어 사용되었는지 체크하도록 하였다.
   *  a부터 z까지 하나씩 배열에 넣어주는 코드는 너무 비효률적이라 생각이 들어 인덱스에 아스키코드 값을 이용했다.
   *  a는 97이라는 값을 가지기 때문에 `bol[st.charAt(i)-97]`같은 방식을 이용하면 st.charAt(i)가 a일 경우 0, b일 경우 1 에 있는 어레이를 가르킬 수 있다.

### seoltaehyeok
<details>
<summary>2941번(크로아티아 알파벳)</summary>
<div markdown="1">   
   
   *  처음 사용했던 코드는 `if~else` 구문을 사용하였다.
   *  입력받은 문자열의 길이만큼 반복문을 진행하고, 각 크로아티아 문자열을 조건식으로 처리했다.
   *  중요한 점은 _다음 배열의 칸이 있을때_ 를 처리해주는 것이었다. `(if < len - 1)`
   *  만약 해당문자가 크로아티아 문자로 바뀔 때 문자열 수가 줄어드므로 반복문 i의 값을 증가시켰다.
      * 예를들면 현재 반복에서 'c'를 처리하고, 다음 반복이 '='일 때, 'c' + '=' 문자열은 크로아티아 알파벳으로 č가 되므로 다음 반복문 값 '='를 받지 않기 위해서이다.
   *  하지만 위 방법은 너무 코드가 길어지고 때문에 다른 방법은 고안했다.
   *  해당하는 아스키코드를 `String`타입 배열에 집어넣는다. `{"c=", "c-", "dz=", "d-", "lj", "nj", "s=", "z="};`
   *  배열의 길이만큼 반복을 진행하고, 입력받는 값 중에 해당 배열의 인덱스에 `contain`(포함)된다면 true를 반환하게 조건문을 실행한다.
   *  그 후 입력받은 문자열을 대체의 문자로 바꿔주는 `replace`를 사용한다. (하나의 문자로 사용하기 위해)
</div>
</details>   
   
<details>
<summary>1316번(그룹 단어 체커)</summary>
<div markdown="1">   
   
   *  체크를 하기 위해, check 메소드를 하나 만들었다.
   *  단어의 개수 N은 100보다 작거나 같은 자연수이므로 배열의 크기를 `char[100]`으로 할당했다.
   *  `main`함수에서는 몇 by case 인지를 할당하였고, 해당 문자열의 길이만큼 `char` 타입 배열에 `toCharArray()`를 통해 입력 문자열을 할당해주었다.
   *  해당 메소드의 매개변수로는 배열타입의 해당 문자열과, 문자열의 길이를 할당해주었다.
   *  해당 문자열의 어떤 값과 현재 값이 같을 경우 문자열의 길이가 3을 넘을 때를 비교한다. (문자열의 길이가 2라면 무조건 그룹단어)
   *  위 조건을 비교한 뒤, 직전 값과 현재 값이 다를 경우 0을 리턴하고, 같다면 나머지 문자열을 반복을 실행한다.
   *  모든 문자열의 반복에서 조건에 부합한다면 1을 리턴하도록 했다.
</div>
</details>
   
### seungyeonpark
*  2941번
    * 논리 연산자를 활용해 복잡한 분기문을 그나마 간단하게 줄일 수 있었다.
    * 24번 line에서 if~else if 구문 안 쓰고 그냥 if 문 두 개 나열했다가 `	런타임 에러 (StringIndexOutOfBounds)` 발생함.
    * 위의 if문에서 i의 값이 바뀌었는데 아래 if문에서 다시 i 변수를 이용해 문자를 읽어와서 발생한 문제였다.
* 1316번
    * 입력 조건 중 `단어는 알파벳 소문자로만 되어있다`라는 조건이 있다. 
        * 그래서 문자의 아스키 코드 값을 불리언 배열의 인덱스로 사용했다.
            ``` java
            checks[s.charAt(j) - 'a'] // 17번 line
            ``` 
        * 위 불리언 배열은 문자가 이전에 등장했는지 여부를 저장하는 배열이다. 이전에 등장했다면 true, 등장한 적이 없다면 false를 저장한다.
    * 문자가 이전에 등장한 경우, 직전 문자와 해당 문자가 동일하지 않다면 그룹 문자가 아니라고 판단했다.
        ``` java
        if (checks[s.charAt(j) - 'a']) {
            if (s.charAt(j) != s.charAt(j - 1)) {
                isGroup = false;
                break;
        } 
        ```
    
